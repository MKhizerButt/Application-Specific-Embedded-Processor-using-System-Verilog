// Isize = 14 = 14'bxxxxxxxxxxxxxx
// format: 3b opcode, 3b %d, 3b %s, 5b xxxxx immediate or address
// %0 0, %1 inport (i) %2 loop index, %3 Current Iteration (i+k), %4 W[i+k], %5 k, G[k] and Iteration Product, %6 ACCUMUALTOR, %7 poll
00000000000000 		// NOP
11001000000001		// ADDI	%2, %0, 1 // Clear and increment by 1; REG 2 = 1
01011100000000		// ADD	%7, %0, 0 // Load poll in REG 7; REG 7 = poll (SW[8])
01111101011111		// BNE  %7, %2, -1;  Branch if %7 != 2; (SW8 != HIGH)
01000100000000		// ADD 	%1, %0, 0 // Load inport in REG 1; REG 1 = inport (SW[7:0])
11011000000000		// ADDI	%6, %0, 0 // Clear Accumulator; REG 6 = 0
11001000011110		// ADDI	%2, %0, -2 // Clear and Set REG 2 to -2
11001100000000		// ADDI	%3, %0, 0 // Clear Iteration Index
01001100100000		// ADD 	%3, %1 // %3 = %3 + %1; Copy inport to REG 3
01001101000000		// ADD 	%3, %2 // %3 = %3 + %2; Current Iteration (i+k) for W in REG 3
10110001100000		// LWW  %4, %3 // Load W[i+k] IN REG 4
11010101000010		// ADD 	%5, %2, 2 // Set index k for G[k] REG 5
11110110100000		// LWG  %5, %5 // Load G[k] in same REG 5  
00110110000000		// MUL  %5, %4 // 0; %5 = %5 * %4; (WAVE[i+k] * G[k]) - Iteration Product
01011010100000		// ADD 	%6, %5 //  %6 = %6 + %5; Accumulator
11001001000001		// ADD 	%2, %2, 1 // Increment REG 2 by 1
11001100000011		// ADD 	%3, %0, 3 // Load 0 in REG 3, and Increment 3 
01101001110110		// BNE  %2, %3, -10; // Branch if 2 != 3 (completes in 5 iterations/Kernel Length from -2 to +2 in REG 2)
01011100000000		// ADD 	%7, %0, 0 // Load poll in REG 7 (LW %i, poll)
01111100011111		// BNE  %7, %0, -1; // Branch if %7!=0 (Keep checking for Poll)
00000000000000 		// NOP
00000000000000 		// NOP
00000000000000 		// NOP
00000000000000 		// NOP
00000000000000 		// NOP
00000000000000 		// NOP
00000000000000 		// NOP
00000000000000 		// NOP
00000000000000 		// NOP
00000000000000 		// NOP
00000000000000 		// NOP
00000000000000 		// NOP